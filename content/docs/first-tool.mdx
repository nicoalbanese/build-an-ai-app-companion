---
title: First Tool
description: First Tool
---
import { Steps, Step } from "fumadocs-ui/components/steps"
import { Callout } from "fumadocs-ui/components/callout"


<Steps>
## Defining the Tool
<Step>
Create your first tool. This will be called `getProducts`.


```tsx title="app/actions.tsx"
// Rest of file

  const result = await streamUI({
    model: openai("gpt-3.5-turbo"),
    messages: [...history.get(), { role: "user", content: input }],
    text: ({ content, done }) => {
      if (done) {
        history.done((messages: ServerMessage[]) => [
          ...messages,
          { role: "assistant", content },
        ]);
      }

      return <div>{content}</div>;
    },
    tools: { 
      getProducts: {
        description: "Get list of products for the company the user asks for.",
        parameters: z.object({
          company: z.object({
            name: z.string(),
          }),
        }),
        generate: async function* ({ company }) {
          yield (
            <div className="animate-pulse p-4 bg-neutral-50 rounded-md">
              Loading {company.name[0].toUpperCase()}
              {company.name.slice(1)} products...
            </div>
          );
          const productsGeneration = await generateObject({
            model: openai("gpt-3.5-turbo"),
            schema: z.object({
              products: z.array(z.string()).min(3),
            }),
            prompt: `Generate realistic products for ${company.name} the user has requested. Use specific model names.`,
          });
          history.done((messages: ServerMessage[]) => [
            ...messages,
            {
              role: "assistant",
              content: `Showing products (products: ${productsGeneration.object.products.map((p) => p).join(", ")})`,
            },
          ]);

          return (
            <ul>
              {productsGeneration.object.products.map((p) => (
                <li key={p}>{p}</li>
              ))}
            </ul>
          );
        },
      },
    }
  });

// Rest of file
```
<Callout>
Note: We are using a generator function here (`function*`), which allows you to pause its execution and return a value, then resume from where it left off on the next call. This makes it useful for handling data streams, as you can fetch and return data from an asynchronous source like an API, then resume the function to fetch the next chunk when needed. By yielding values one at a time, generator functions enable efficient processing of streaming data without blocking the main thread.
</Callout>
</Step>

## Generate a Products Component
<Step>
Head to v0 and generate a component to display your "products". You could use a [carousel](https://v0.dev/t/VFdYPYy7iUy) for example. Install it with `npx v0 component-id` and name it `ProductCarousel`.
</Step>

<Step>
Update the component to map through the products and display the product details.
```tsx title="components/product-carousel.tsx"
/**
 * This code was generated by v0 by Vercel.
 * @see https://v0.dev/t/VFdYPYy7iUy
 * Documentation: https://v0.dev/docs#integrating-generated-code-into-your-nextjs-app
**/
import { Card } from "@/components/ui/card";
import {
  CarouselItem,
  CarouselContent,
  CarouselPrevious,
  CarouselNext,
  Carousel,
} from "@/components/ui/carousel";

export function ProductCarousel({
  products,
}: {
  products?: { name: string; description: string }[];
}) {
  console.log(products);
  return (
    <Carousel className="w-full max-w-2xl">
      <CarouselContent>
        {products?.map((p) => (
          <CarouselItem key={p.name}>
            <Card className="flex flex-col items-center gap-4 p-6">
              <div className="text-center">
                <h3 className="text-xl font-semibold">{p.name}</h3>
                <p className="text-gray-500 dark:text-gray-400">
                  {p.description}
                </p>
              </div>
            </Card>
          </CarouselItem>
        ))}
      </CarouselContent>
      <CarouselPrevious />
      <CarouselNext />
    </Carousel>
  );
}
```

</Step>

<Step>
Go back to your Server Action and update the generated products schema to generate a `description`, `price`, and `type`. Return the newly generated `ProductCarousel` component, passing in the generated products as a prop.


```tsx title="app/actions.tsx"
// Rest of file
    tools: {
      getProducts: {
        description:
          "Get list of products for the company the user asks for. Only use when the user asks for products. If the user doesn't specify a company, be sure to ask.",
        parameters: z.object({
          company: z.object({
            name: z.string(),
          }),
        }),
        generate: async function* ({ company }) {
          yield (
            <div className="animate-pulse p-4 bg-neutral-50 rounded-md">
              Loading {company.name[0].toUpperCase()}
              {company.name.slice(1)} products...
            </div>
          );
          const productsGeneration = await generateObject({
            model: openai("gpt-3.5-turbo"),
            schema: z.object({
              products: z
                .array(
                  z.object({
                    name: z.string(),
                    description: z.string(),
                    price: z.number(),
                    type: z.enum(["one-off", "subscription"]),
                  }),
                )
                .min(5),
            }),
            prompt: `Generate realistic products for ${company.name} the user has requested. Use specific model names.`,
          });
          history.done((messages: ServerMessage[]) => [
            ...messages,
            {
              role: "assistant",
              content: `Showing products (products: ${productsGeneration.object.products.map((p) => p.name).join(", ")})`,
            },
          ]);
          return <ProductCarousel products={productsGeneration.object.products} />;
        },
      },
    }
// Rest of file
```
</Step>
</Steps>